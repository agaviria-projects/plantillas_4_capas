# En un DER, las relaciones siempre se hacen mediante llaves forÃ¡neas (FK) que apuntan a llaves primarias (PK) de otras tablas. Las PK no deben depender de otras tablas, pero sÃ­ pueden ser objetivo de muchas FK.


# âœ… ðŸ“„ Plantilla Base para una Entidad JPA (Ej. Categoria.java)
package com.saborlatino.barsystem.model;

import jakarta.persistence.*;
import java.util.List;

@Entity
@Table(name = "categorias")
public class Categoria {

    // ðŸ”¹ Atributo ID con llave primaria
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // ðŸ”¹ Atributo normal con longitud personalizada
    @Column(name = "nombre_categoria", length = 50, nullable = false)
    private String nombre;

    //  RelaciÃ³n con Producto (OneToMany)
    @OneToMany(mappedBy = "categoria", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Producto> productos;

    // ðŸ”¹ Constructor vacÃ­o (obligatorio para JPA)
    public Categoria() {}

    // ðŸ”¹ Constructor con parÃ¡metros Ãºtiles (opcional)
    public Categoria(String nombre) {
        this.nombre = nombre;
    }

    // ðŸ”¹ Getters y Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public List<Producto> getProductos() {
        return productos;
    }

    public void setProductos(List<Producto> productos) {
        this.productos = productos;
    }
}


# âœ… ðŸ“„ Y su contraparte: Plantilla para Producto.java
package com.saborlatino.barsystem.model;

import jakarta.persistence.*;

@Entity
@Table(name = "productos")
public class Producto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "nombre_producto", length = 100, nullable = false)
    private String nombre;

    @Column(name = "precio", precision = 10, scale = 2)
    private Double precio;

    // ðŸ”¹ RelaciÃ³n con CategorÃ­a (Muchos a Uno)
    @ManyToOne
    @JoinColumn(name = "id_categoria")
    private Categoria categoria;

    // ðŸ”¹ Constructor vacÃ­o
    public Producto() {}

    // ðŸ”¹ Constructor Ãºtil
    public Producto(String nombre, Double precio, Categoria categoria) {
        this.nombre = nombre;
        this.precio = precio;
        this.categoria = categoria;
    }

    // ðŸ”¹ Getters y Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getNombre() {
        return nombre;
    }

    public void setNombre(String nombre) {
        this.nombre = nombre;
    }

    public Double getPrecio() {
        return precio;
    }

    public void setPrecio(Double precio) {
        this.precio = precio;
    }

    public Categoria getCategoria() {
        return categoria;
    }

    public void setCategoria(Categoria categoria) {
        this.categoria = categoria;
    }
}

# ðŸ§  Â¿QuÃ© debes recordar siempre?
Elemento	                Â¿Por quÃ© se usa?
@Entity	                    Para que Spring lo entienda como tabla
@Table(name = "nombre") 	Para definir el nombre real en la BD
@Id y @GeneratedValue	    Para la clave primaria
@Column(...)	            Para personalizar campos (nombre, longitud, nulos)
@OneToMany, @ManyToOne	    Para establecer relaciones entre tablas
constructor vacÃ­o	        Obligatorio para que Hibernate pueda crear instancias automÃ¡ticamente
getters y setters	        Necesarios para acceder a los datos desde el resto de la aplicaciÃ³n.

# âœ… Â¿CuÃ¡ndo usar @Column(...)?

# Usas @Column(...) cuando necesitas:

    Cambiar el nombre del campo en la base de datos (name = "correo")

    Controlar el tamaÃ±o del campo (length = 100)

    Establecer si puede ser nulo o no (nullable = false)

    Personalizar precisiÃ³n y escala si es decimal (precision, scale)

# ðŸ”¸ Para campos tipo String, como correo, password, rol:

@Column(name = "correo", length = 100, nullable = false)
private String correo;

@Column(name = "password", length = 100, nullable = false)
private String password;

@Column(name = "rol", length = 20, nullable = false)
private String rol;


     Usa length para limitar el tamaÃ±o en la base de datos.

# ðŸ”¸ Para campos tipo BigDecimal, como precios:

@Column(name = "precio_compra", precision = 10, scale = 2, nullable = false)
private BigDecimal precioCompra;

@Column(name = "precio_venta", precision = 10, scale = 2, nullable = false)
private BigDecimal precioVenta;

    ðŸ§  precision = 10 significa 10 dÃ­gitos en total,
    scale = 2 significa 2 decimales â†’ 99999999.99 mÃ¡ximo.

# ðŸ”¸ Para campos tipo Integer, como stock:

@Column(name = "stock_actual", nullable = false)
private Integer stockActual;

    ðŸ§  No necesitas length aquÃ­. Solo defines nullable.

# ðŸ”¸ Para campos tipo LocalDate, como fechas:

@Column(name = "fecha_registro", nullable = false)
private LocalDate fechaRegistro;

    ðŸ§  LocalDate se mapea automÃ¡ticamente a DATE en MySQL.

# ðŸ’¡ Si no personalizas nada, puedes dejarlo sin @Column:

private String correo;

# ðŸ§© 1. @OneToMany

Esto indica la relaciÃ³n de uno a muchos:

    Una CategorÃ­a puede tener muchos Productos asociados.

    Va siempre del lado que tiene la lista (List<Producto>).

# ðŸ§© 2. mappedBy = "categoria"

Esto significa:

    La relaciÃ³n ya estÃ¡ mapeada desde el otro lado, es decir, desde la entidad Producto.

    "categoria" hace referencia al nombre del atributo en la clase Producto que estÃ¡ anotado con @ManyToOne.

Ejemplo en Producto.java:

@ManyToOne
@JoinColumn(name = "id_categoria")
private Categoria categoria;

    ðŸ‘‰ Por eso en Categoria.java se usa mappedBy = "categoria" (coincide con el nombre de ese atributo).

# ðŸ§© 3. cascade = CascadeType.ALL

Esto permite que las operaciones hechas en Categoria se repliquen automÃ¡ticamente en sus productos.

Por ejemplo:

    Si guardas una nueva Categoria, automÃ¡ticamente se guardan sus Productos.

    Si borras una Categoria, tambiÃ©n se borran sus Productos.

CascadeType.ALL = Aplica todos los tipos de cascada (persist, merge, remove, refresh, detach).

# ðŸ§© 4. orphanRemoval = true

Este es clave:

    Significa: si eliminas un Producto de la lista productos en la categorÃ­a, ese producto tambiÃ©n se elimina de la base de datos.

    Ãštil para evitar registros huÃ©rfanos.

Ejemplo:

categoria.getProductos().remove(productoX);
// El productoX se elimina automÃ¡ticamente de la BD si esta propiedad estÃ¡ en true
